"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AuthInterceptor: () => AuthInterceptor,
  ErrorNormalizer: () => ErrorNormalizer,
  HttpClient: () => HttpClient,
  PlatformInterceptors: () => PlatformInterceptors,
  RetryHandler: () => RetryHandler,
  TenantResolver: () => TenantResolver,
  addPlatformInterceptors: () => addPlatformInterceptors,
  createApiQuery: () => createApiQuery,
  createAuthClient: () => createAuthClient,
  createHttpClient: () => createHttpClient,
  createHttpClientForQuery: () => createHttpClientForQuery,
  createPlatformInterceptors: () => createPlatformInterceptors,
  createTenantClient: () => createTenantClient,
  httpClient: () => httpClient,
  useApiMutation: () => useApiMutation,
  useApiQuery: () => useApiQuery
});
module.exports = __toCommonJS(index_exports);

// src/http-client.ts
var import_axios = __toESM(require("axios"));

// src/tenant-resolver.ts
var import_js_cookie = __toESM(require("js-cookie"));
var TenantResolver = class _TenantResolver {
  constructor(config) {
    this.config = config;
  }
  getTenantId() {
    const { source, tenantId } = this.config;
    switch (source) {
      case "header":
        return tenantId;
      case "subdomain":
        return this.extractTenantFromSubdomain();
      case "query":
        return this.extractTenantFromQuery();
      case "cookie":
        return this.extractTenantFromCookie();
      default:
        return tenantId || null;
    }
  }
  extractTenantFromSubdomain() {
    if (typeof window === "undefined") return null;
    const hostname = window.location.hostname;
    const parts = hostname.split(".");
    if (parts.length > 2) {
      return parts[0] || null;
    }
    return null;
  }
  extractTenantFromQuery() {
    if (typeof window === "undefined") return null;
    const urlParams = new URLSearchParams(window.location.search);
    const tenant = urlParams.get("tenant") || urlParams.get("tenantId");
    return tenant || null;
  }
  extractTenantFromCookie() {
    const cookie = import_js_cookie.default.get("tenant-id") || import_js_cookie.default.get("tenantId");
    return cookie || null;
  }
  static fromHostname() {
    const tenantId = typeof window !== "undefined" ? window.location.hostname.split(".")[0] : "";
    return new _TenantResolver({
      tenantId: tenantId || "",
      source: "subdomain"
    });
  }
  static fromConfig(tenantId) {
    return new _TenantResolver({
      tenantId,
      source: "header"
    });
  }
};

// src/error-normalizer.ts
var ErrorNormalizer = class {
  static normalize(error) {
    if (error.isAxiosError) {
      return this.normalizeAxiosError(error);
    }
    if (error instanceof Error) {
      return this.normalizeGenericError(error);
    }
    if (typeof error === "string") {
      return {
        message: error,
        code: "UNKNOWN_ERROR"
      };
    }
    return {
      message: "An unknown error occurred",
      code: "UNKNOWN_ERROR",
      details: error
    };
  }
  static normalizeAxiosError(error) {
    const { response, request, message } = error;
    if (response) {
      const { status, data } = response;
      const errorMessage = this.extractErrorMessage(data);
      return {
        message: errorMessage || this.getStatusMessage(status),
        code: this.getErrorCode(status),
        status,
        details: data
      };
    }
    if (request) {
      return {
        message: "Network error - no response received",
        code: "NETWORK_ERROR"
      };
    }
    return {
      message: message || "Request configuration error",
      code: "REQUEST_ERROR"
    };
  }
  static normalizeGenericError(error) {
    return {
      message: error.message || "An error occurred",
      code: "GENERIC_ERROR"
    };
  }
  static extractErrorMessage(data) {
    if (!data) return null;
    if (typeof data === "string") return data;
    if (data.message) return data.message;
    if (data.error) return data.error;
    if (data.detail) return data.detail;
    if (data.errors && Array.isArray(data.errors) && data.errors.length > 0) {
      return data.errors[0];
    }
    return null;
  }
  static getStatusMessage(status) {
    const statusMessages = {
      400: "Bad Request",
      401: "Unauthorized - Please log in",
      403: "Forbidden - Access denied",
      404: "Resource not found",
      409: "Conflict - Resource already exists",
      422: "Validation error",
      429: "Too many requests - Please try again later",
      500: "Internal server error",
      502: "Bad Gateway",
      503: "Service unavailable",
      504: "Gateway timeout"
    };
    return statusMessages[status] || `HTTP Error ${status}`;
  }
  static getErrorCode(status) {
    const statusCodes = {
      400: "BAD_REQUEST",
      401: "UNAUTHORIZED",
      403: "FORBIDDEN",
      404: "NOT_FOUND",
      409: "CONFLICT",
      422: "VALIDATION_ERROR",
      429: "TOO_MANY_REQUESTS",
      500: "INTERNAL_SERVER_ERROR",
      502: "BAD_GATEWAY",
      503: "SERVICE_UNAVAILABLE",
      504: "GATEWAY_TIMEOUT"
    };
    return statusCodes[status] || "HTTP_ERROR";
  }
  static isNetworkError(error) {
    return error.code === "NETWORK_ERROR";
  }
  static isAuthError(error) {
    return error.status === 401 || error.code === "UNAUTHORIZED";
  }
  static isValidationError(error) {
    return error.status === 422 || error.code === "VALIDATION_ERROR";
  }
  static isRetryableError(error) {
    if (this.isNetworkError(error)) return true;
    if (error.status && [429, 502, 503, 504].includes(error.status)) return true;
    return false;
  }
};

// src/retry-handler.ts
var RetryHandler = class _RetryHandler {
  constructor(config = {}) {
    this.config = {
      retries: 3,
      retryDelay: 1e3,
      shouldRetry: ErrorNormalizer.isRetryableError,
      ...config
    };
  }
  async execute(operation, currentAttempt = 0) {
    try {
      return await operation();
    } catch (error) {
      const normalizedError = ErrorNormalizer.normalize(error);
      if (this.shouldRetry(normalizedError, currentAttempt)) {
        await this.delay(currentAttempt);
        return this.execute(operation, currentAttempt + 1);
      }
      throw normalizedError;
    }
  }
  shouldRetry(error, currentAttempt) {
    if (currentAttempt >= this.config.retries) {
      return false;
    }
    return this.config.shouldRetry(error);
  }
  delay(attempt) {
    const delay = this.calculateDelay(attempt);
    return new Promise((resolve) => setTimeout(resolve, delay));
  }
  calculateDelay(attempt) {
    const baseDelay = this.config.retryDelay;
    const exponentialDelay = baseDelay * Math.pow(2, attempt);
    const jitter = Math.random() * 0.1 * exponentialDelay;
    return Math.min(exponentialDelay + jitter, 3e4);
  }
  static create(config) {
    return new _RetryHandler(config);
  }
};

// src/auth-interceptor.ts
var import_js_cookie2 = __toESM(require("js-cookie"));
var AuthInterceptor = class {
  constructor(config = {}) {
    this.requestInterceptor = (config) => {
      const token = this.getToken();
      if (token && !this.isSkipAuth(config)) {
        config.headers = config.headers || {};
        config.headers[this.config.headerName] = `${this.config.headerPrefix} ${token}`;
      }
      return config;
    };
    this.responseInterceptor = {
      onFulfilled: (response) => response,
      onRejected: async (error) => {
        const originalRequest = error.config;
        if (error.response?.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true;
          try {
            const newToken = await this.refreshToken();
            if (newToken) {
              originalRequest.headers[this.config.headerName] = `${this.config.headerPrefix} ${newToken}`;
              return await this.retryRequest(originalRequest);
            }
          } catch (refreshError) {
            this.clearTokens();
            this.handleAuthFailure();
          }
        }
        return Promise.reject(error);
      }
    };
    this.config = {
      tokenSource: "cookie",
      tokenKey: "access_token",
      refreshTokenKey: "refresh_token",
      headerName: "Authorization",
      headerPrefix: "Bearer",
      refreshEndpoint: "/api/auth/refresh",
      ...config
    };
  }
  getToken() {
    switch (this.config.tokenSource) {
      case "cookie":
        return import_js_cookie2.default.get(this.config.tokenKey) || null;
      case "localStorage":
        if (typeof window !== "undefined") {
          return localStorage.getItem(this.config.tokenKey);
        }
        return null;
      case "sessionStorage":
        if (typeof window !== "undefined") {
          return sessionStorage.getItem(this.config.tokenKey);
        }
        return null;
      default:
        return null;
    }
  }
  async refreshToken() {
    const refreshToken = this.getRefreshToken();
    if (!refreshToken || !this.config.refreshEndpoint) {
      return null;
    }
    try {
      const response = await fetch(this.config.refreshEndpoint, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ refresh_token: refreshToken })
      });
      if (!response.ok) {
        return null;
      }
      const data = await response.json();
      if (!data || typeof data !== "object") {
        return null;
      }
      const { access_token, refresh_token } = data;
      const newToken = typeof access_token === "string" ? access_token : null;
      const newRefreshToken = typeof refresh_token === "string" ? refresh_token : null;
      if (newToken) {
        this.setToken(newToken);
        if (newRefreshToken) {
          this.setRefreshToken(newRefreshToken);
        }
        return newToken;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
    }
    return null;
  }
  getRefreshToken() {
    if (!this.config.refreshTokenKey) return null;
    switch (this.config.tokenSource) {
      case "cookie":
        return import_js_cookie2.default.get(this.config.refreshTokenKey) || null;
      case "localStorage":
        if (typeof window !== "undefined") {
          return localStorage.getItem(this.config.refreshTokenKey);
        }
        return null;
      case "sessionStorage":
        if (typeof window !== "undefined") {
          return sessionStorage.getItem(this.config.refreshTokenKey);
        }
        return null;
      default:
        return null;
    }
  }
  setToken(token) {
    switch (this.config.tokenSource) {
      case "cookie":
        import_js_cookie2.default.set(this.config.tokenKey, token, {
          secure: true,
          sameSite: "strict",
          expires: 7
          // 7 days
        });
        break;
      case "localStorage":
        if (typeof window !== "undefined") {
          localStorage.setItem(this.config.tokenKey, token);
        }
        break;
      case "sessionStorage":
        if (typeof window !== "undefined") {
          sessionStorage.setItem(this.config.tokenKey, token);
        }
        break;
    }
  }
  setRefreshToken(token) {
    if (!this.config.refreshTokenKey) return;
    switch (this.config.tokenSource) {
      case "cookie":
        import_js_cookie2.default.set(this.config.refreshTokenKey, token, {
          secure: true,
          sameSite: "strict",
          expires: 30
          // 30 days
        });
        break;
      case "localStorage":
        if (typeof window !== "undefined") {
          localStorage.setItem(this.config.refreshTokenKey, token);
        }
        break;
      case "sessionStorage":
        if (typeof window !== "undefined") {
          sessionStorage.setItem(this.config.refreshTokenKey, token);
        }
        break;
    }
  }
  clearTokens() {
    switch (this.config.tokenSource) {
      case "cookie":
        import_js_cookie2.default.remove(this.config.tokenKey);
        if (this.config.refreshTokenKey) {
          import_js_cookie2.default.remove(this.config.refreshTokenKey);
        }
        break;
      case "localStorage":
        if (typeof window !== "undefined") {
          localStorage.removeItem(this.config.tokenKey);
          if (this.config.refreshTokenKey) {
            localStorage.removeItem(this.config.refreshTokenKey);
          }
        }
        break;
      case "sessionStorage":
        if (typeof window !== "undefined") {
          sessionStorage.removeItem(this.config.tokenKey);
          if (this.config.refreshTokenKey) {
            sessionStorage.removeItem(this.config.refreshTokenKey);
          }
        }
        break;
    }
  }
  async retryRequest(config) {
    throw new Error("Retry request needs to be handled by HttpClient");
  }
  handleAuthFailure() {
    if (typeof window !== "undefined") {
      window.dispatchEvent(
        new CustomEvent("auth:failure", {
          detail: { reason: "token_refresh_failed" }
        })
      );
    }
  }
  isSkipAuth(config) {
    return config?.skipAuth === true;
  }
};

// src/http-client.ts
var HttpClient = class _HttpClient {
  constructor(config = {}) {
    this.tenantResolver = null;
    this.authInterceptor = null;
    this.config = {
      baseURL: "",
      timeout: 3e4,
      retries: 3,
      retryDelay: 1e3,
      tenantIdSource: "subdomain",
      authTokenSource: "cookie",
      ...config
    };
    this.retryHandler = new RetryHandler({
      retries: this.config.retries,
      retryDelay: this.config.retryDelay
    });
    this.axiosInstance = import_axios.default.create({
      baseURL: this.config.baseURL,
      timeout: this.config.timeout,
      headers: {
        "Content-Type": "application/json"
      }
    });
    this.setupInterceptors();
  }
  setupInterceptors() {
    this.axiosInstance.interceptors.request.use(
      (config) => {
        if (!this.isSkipTenantId(config)) {
          const tenantId = this.tenantResolver?.getTenantId();
          if (tenantId) {
            config.headers = config.headers || {};
            config.headers["X-Tenant-ID"] = tenantId;
          }
        }
        return config;
      },
      (error) => Promise.reject(ErrorNormalizer.normalize(error))
    );
    this.axiosInstance.interceptors.response.use(
      (response) => response,
      (error) => {
        const normalizedError = ErrorNormalizer.normalize(error);
        return Promise.reject(normalizedError);
      }
    );
  }
  // Configuration methods
  setTenantResolver(resolver) {
    this.tenantResolver = resolver;
    return this;
  }
  setTenantFromHostname() {
    this.tenantResolver = TenantResolver.fromHostname();
    return this;
  }
  setTenantId(tenantId) {
    this.tenantResolver = TenantResolver.fromConfig(tenantId);
    return this;
  }
  enableAuth(authConfig) {
    this.authInterceptor = new AuthInterceptor({
      tokenSource: this.config.authTokenSource,
      ...authConfig
    });
    this.axiosInstance.interceptors.request.use(
      this.authInterceptor.requestInterceptor,
      (error) => Promise.reject(ErrorNormalizer.normalize(error))
    );
    this.axiosInstance.interceptors.response.use(
      this.authInterceptor.responseInterceptor.onFulfilled,
      async (error) => {
        try {
          return await this.authInterceptor.responseInterceptor.onRejected(error);
        } catch (authError) {
          return Promise.reject(ErrorNormalizer.normalize(authError));
        }
      }
    );
    return this;
  }
  // HTTP methods with retry logic
  async get(url, config = {}) {
    return this.request("GET", url, void 0, config);
  }
  async post(url, data, config = {}) {
    return this.request("POST", url, data, config);
  }
  async put(url, data, config = {}) {
    return this.request("PUT", url, data, config);
  }
  async patch(url, data, config = {}) {
    return this.request("PATCH", url, data, config);
  }
  async delete(url, config = {}) {
    return this.request("DELETE", url, void 0, config);
  }
  // Core request method
  async request(method, url, data, config = {}) {
    const requestConfig = {
      method: method.toLowerCase(),
      url,
      data,
      ...config
    };
    const operation = () => this.axiosInstance.request(requestConfig);
    try {
      const response = config.skipRetry ? await operation() : await this.retryHandler.execute(operation);
      return this.normalizeResponse(response);
    } catch (error) {
      throw ErrorNormalizer.normalize(error);
    }
  }
  normalizeResponse(response) {
    return {
      data: response.data,
      success: true,
      message: "Request successful"
    };
  }
  isSkipTenantId(config) {
    if (!config) {
      return false;
    }
    return config.skipTenantId === true;
  }
  // Utility methods
  getAxiosInstance() {
    return this.axiosInstance;
  }
  getCurrentTenantId() {
    return this.tenantResolver?.getTenantId() || null;
  }
  // Static factory methods
  static create(config) {
    return new _HttpClient(config);
  }
  static createWithTenant(tenantId, config) {
    return new _HttpClient(config).setTenantId(tenantId);
  }
  static createFromHostname(config) {
    return new _HttpClient(config).setTenantFromHostname();
  }
  static createWithAuth(authConfig, httpConfig) {
    return new _HttpClient(httpConfig).enableAuth(authConfig);
  }
};

// src/platform-interceptors.ts
var import_uuid = require("uuid");
var PlatformInterceptors = class {
  constructor(config = {}) {
    /**
     * Request interceptor for platform services integration
     */
    this.requestInterceptor = (config) => {
      config.headers = config.headers || {};
      if (this.config.enableCorrelationId) {
        const correlationId = (0, import_uuid.v4)();
        config.headers["X-Correlation-ID"] = correlationId;
        config.__correlationId = correlationId;
      }
      if (this.config.enableAuditLogging) {
        config.headers["X-Audit-Context"] = JSON.stringify({
          component: "frontend",
          user_agent: navigator.userAgent,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          url: window.location.href,
          method: config.method?.toUpperCase(),
          endpoint: config.url
        });
      }
      if (this.config.enableServiceRegistry && this.isPlatformServiceRequest(config.url)) {
        config.headers["X-Service-Discovery"] = "enabled";
        config.headers["X-Client-Type"] = "web-frontend";
        config.headers["X-Client-Version"] = process.env["VITE_APP_VERSION"] || "1.0.0";
      }
      config.__requestStartTime = Date.now();
      return config;
    };
    /**
     * Response interceptor for platform services integration
     */
    this.responseInterceptor = {
      onFulfilled: (response) => {
        const startTime = response.config.__requestStartTime;
        if (startTime) {
          const responseTime = Date.now() - startTime;
          response.headers["x-response-time"] = responseTime.toString();
          if (responseTime > 5e3) {
            console.warn(`Slow request detected: ${response.config.url} took ${responseTime}ms`);
          }
        }
        if (this.isServiceRegistryResponse(response)) {
          this.handleServiceRegistryResponse(response);
        }
        return response;
      },
      onRejected: async (error) => {
        const correlationId = error.config?.__correlationId;
        if (correlationId) {
          error.correlationId = correlationId;
        }
        if (error.response) {
          error.platformContext = {
            status: error.response.status,
            endpoint: error.config?.url,
            method: error.config?.method?.toUpperCase(),
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            correlationId
          };
        }
        if (error.response?.status === 423) {
          error.isLockConflict = true;
          error.lockInfo = error.response.data?.lock_info;
        }
        if (error.response?.status === 429) {
          error.rateLimitInfo = {
            retryAfter: error.response.headers["retry-after"],
            limit: error.response.headers["x-ratelimit-limit"],
            remaining: error.response.headers["x-ratelimit-remaining"],
            reset: error.response.headers["x-ratelimit-reset"]
          };
        }
        return Promise.reject(error);
      }
    };
    this.config = {
      enableAuditLogging: true,
      enableCorrelationId: true,
      enableServiceRegistry: false,
      platformApiPrefix: "/api",
      ...config
    };
  }
  isPlatformServiceRequest(url) {
    if (!url) return false;
    const platformEndpoints = [
      "/service-registry",
      "/audit-trail",
      "/distributed-locks",
      "/auth",
      "/tenant"
    ];
    return platformEndpoints.some(
      (endpoint) => url.includes(`${this.config.platformApiPrefix}${endpoint}`)
    );
  }
  isServiceRegistryResponse(response) {
    return response.config.url?.includes("/service-registry") ?? false;
  }
  handleServiceRegistryResponse(response) {
    if (response.data?.services) {
      const healthyServices = response.data.services.filter(
        (service) => service.status === "healthy"
      );
      sessionStorage.setItem(
        "dotmac:healthy-services",
        JSON.stringify({
          services: healthyServices,
          updatedAt: Date.now()
        })
      );
    }
  }
};
function createPlatformInterceptors(config) {
  return new PlatformInterceptors(config);
}
function addPlatformInterceptors(httpClient2, config) {
  const interceptors = createPlatformInterceptors(config);
  httpClient2.axiosInstance.interceptors.request.use(
    interceptors.requestInterceptor,
    (error) => Promise.reject(error)
  );
  httpClient2.axiosInstance.interceptors.response.use(
    interceptors.responseInterceptor.onFulfilled,
    interceptors.responseInterceptor.onRejected
  );
}

// src/react-query.ts
var import_react_query = require("@tanstack/react-query");
function createApiQuery(request) {
  return {
    execute: request
  };
}
function useApiQuery(key, descriptor, options) {
  return (0, import_react_query.useQuery)({
    queryKey: key,
    queryFn: descriptor.execute,
    ...options
  });
}
function useApiMutation(descriptor, options) {
  const queryClient = (0, import_react_query.useQueryClient)();
  return (0, import_react_query.useMutation)({
    mutationFn: descriptor,
    ...options,
    onError: (error, variables, context, mutation) => {
      options?.onError?.(error, variables, context, mutation);
    },
    onSuccess: (data, variables, context, mutation) => {
      options?.onSuccess?.(data, variables, context, mutation);
    },
    onSettled: async (data, error, variables, context, mutation) => {
      if (options?.onSettled) {
        await options.onSettled(data, error, variables, context, mutation);
      }
      if (options?.invalidateQueries) {
        await Promise.all(
          options.invalidateQueries.map(
            (invalidateKey) => queryClient.invalidateQueries({ queryKey: invalidateKey })
          )
        );
      }
    }
  });
}
function createHttpClientForQuery(config) {
  return HttpClient.create({ ...config }).enableAuth();
}

// src/index.ts
var httpClient = HttpClient.createFromHostname({
  timeout: 3e4,
  retries: 3
}).enableAuth();
var createHttpClient = HttpClient.create;
var createTenantClient = HttpClient.createWithTenant;
var createAuthClient = HttpClient.createWithAuth;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthInterceptor,
  ErrorNormalizer,
  HttpClient,
  PlatformInterceptors,
  RetryHandler,
  TenantResolver,
  addPlatformInterceptors,
  createApiQuery,
  createAuthClient,
  createHttpClient,
  createHttpClientForQuery,
  createPlatformInterceptors,
  createTenantClient,
  httpClient,
  useApiMutation,
  useApiQuery
});
